import argparse
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

def rk4_step(f, y, t, dt):
    k1 = f(t, y)
    k2 = f(t + 0.5 * dt, y + 0.5 * dt * k1)
    k3 = f(t + 0.5 * dt, y + 0.5 * dt * k2)
    k4 = f(t + dt, y + dt * k3)
    return y + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)

class NPendulum:
    """
    Planar N-pendulum with point masses at the joints (one mass per link end),
    generalized coordinates theta_i measured from vertical (down is theta=0),
    with rod lengths L_i.

    Equations (no drive):
        M(theta) * theta_ddot + C(theta, theta_dot) + G(theta) + D(theta_dot) = 0
    """
    def __init__(self, N, lengths=None, masses=None, g=9.81, damping=0.0):
        self.N = int(N)
        self.g = float(g)
        self.damping = float(damping)

        if lengths is None:
            lengths = np.ones(self.N, dtype=float)
        if masses is None:
            masses = np.ones(self.N, dtype=float)

        self.L = np.asarray(lengths, dtype=float).reshape(-1)
        self.m = np.asarray(masses, dtype=float).reshape(-1)

        if self.L.size != self.N or self.m.size != self.N:
            raise ValueError("lengths and masses must each have length N")

        # suffix mass sums: m_suffix[i] = sum_{k=i..N-1} m_k
        self.m_suffix = np.array([self.m[i:].sum() for i in range(self.N)], dtype=float)

        # index map for s_{ab} = m_suffix[max(a,b)]
        idx = np.maximum.outer(np.arange(self.N), np.arange(self.N))
        self._suffix_map = idx  # used to index into m_suffix

    def _mass_matrix_and_dM(self, th):
        """
        Returns:
          M: (N,N)
          dM: (N,N,N) where dM[l,a,b] = ∂M[a,b]/∂theta_l
        """
        N = self.N
        L = self.L
        s = self.m_suffix[self._suffix_map]  # (N,N), s[a,b]=m_suffix[max(a,b)]

        delta = th[:, None] - th[None, :]    # (N,N) with delta[a,b]=th[a]-th[b]
        cosd = np.cos(delta)
        sind = np.sin(delta)

        LL = L[:, None] * L[None, :]
        M = s * LL * cosd

        # Build dM efficiently: only nonzero when l==a or l==b.
        dM = np.zeros((N, N, N), dtype=float)

        # l == a : ∂/∂th_a cos(th_a-th_b) = -sin(th_a-th_b)
        for l in range(N):
            dM[l, l, :] = -s[l, :] * (L[l] * L) * sind[l, :]

        # l == b : ∂/∂th_b cos(th_a-th_b) = +sin(th_a-th_b)
        # Add into dM[l, :, l]
        for l in range(N):
            dM[l, :, l] += s[:, l] * (L * L[l]) * sind[:, l]

        return M, dM

    def mass_matrix(self, th):
        M, _ = self._mass_matrix_and_dM(th)
        # (optional) enforce symmetry against tiny FP drift
        return 0.5 * (M + M.T)

    def gravity_vec(self, th):
        # G_j = ∂V/∂θ_j = g * m_suffix[j] * L_j * sin(θ_j)
        return self.g * self.L * self.m_suffix * np.sin(th)

    def coriolis_vec(self, th, w):
        """
        C_j = Σ_{k,l} Γ_{jkl} w_k w_l,
        Γ_{jkl} = 1/2(∂M_{jk}/∂θ_l + ∂M_{jl}/∂θ_k - ∂M_{kl}/∂θ_j)
        """
        M, dM = self._mass_matrix_and_dM(th)

        # term1_j = Σ_{k,l} (∂M_{jk}/∂θ_l) w_k w_l = Σ_{k,l} dM[l,j,k] w_k w_l
        term1 = np.einsum("ljk,k,l->j", dM, w, w)

        # term2_j = Σ_{k,l} (∂M_{jl}/∂θ_k) w_k w_l = Σ_{k,l} dM[k,j,l] w_k w_l
        term2 = np.einsum("kjl,k,l->j", dM.transpose(2, 1, 0), w, w)

        # term3_j = Σ_{k,l} (∂M_{kl}/∂θ_j) w_k w_l = Σ_{k,l} dM[j,k,l] w_k w_l
        term3 = np.einsum("jkl,k,l->j", dM, w, w)

        C = 0.5 * (term1 + term2 - term3)
        return C

    def deriv(self, t, y):
        N = self.N
        th = y[:N]
        w = y[N:]

        M = self.mass_matrix(th)
        C = self.coriolis_vec(th, w)
        G = self.gravity_vec(th)
        D = self.damping * w

        rhs = -(C + G + D)
        a = np.linalg.solve(M, rhs)

        dy = np.empty_like(y)
        dy[:N] = w
        dy[N:] = a
        return dy

    def positions(self, th):
        x = np.zeros(self.N + 1, dtype=float)
        y = np.zeros(self.N + 1, dtype=float)
        for i in range(1, self.N + 1):
            k = i - 1
            x[i] = x[i - 1] + self.L[k] * np.sin(th[k])
            y[i] = y[i - 1] - self.L[k] * np.cos(th[k])
        return x, y


def parse_list(s, N, name):
    if s is None:
        return None
    parts = [p.strip() for p in s.split(",") if p.strip() != ""]
    if len(parts) == 1:
        v = float(parts[0])
        return np.full(N, v, dtype=float)
    if len(parts) != N:
        raise ValueError(f"{name} must be a single value or {N} comma-separated values")
    return np.array([float(p) for p in parts], dtype=float)


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--N", type=int, default=None)
    ap.add_argument("--dt", type=float, default=0.003)
    ap.add_argument("--steps-per-frame", type=int, default=5)
    ap.add_argument("--fps", type=float, default=60.0)
    ap.add_argument("--g", type=float, default=9.81)
    ap.add_argument("--damping", type=float, default=0.02)
    ap.add_argument("--lengths", type=str, default=None)
    ap.add_argument("--masses", type=str, default=None)
    ap.add_argument("--theta0-deg", type=str, default=None)
    ap.add_argument("--omega0", type=str, default=None)
    ap.add_argument("--random-init", action="store_true")
    ap.add_argument("--seed", type=int, default=0)
    args = ap.parse_args()

    if args.N is None:
        try:
            args.N = int(input("Choose N (e.g. 2 for double pendulum): ").strip())
        except Exception:
            raise SystemExit("Invalid N")

    N = int(args.N)
    if N < 1:
        raise SystemExit("N must be >= 1")

    lengths = parse_list(args.lengths, N, "lengths")
    masses = parse_list(args.masses, N, "masses")
    sim = NPendulum(N, lengths=lengths, masses=masses, g=args.g, damping=args.damping)

    rng = np.random.default_rng(args.seed)

    th0 = parse_list(args.theta0_deg, N, "theta0-deg")
    w0 = parse_list(args.omega0, N, "omega0")

    if th0 is None:
        if args.random_init:
            th0 = rng.uniform(low=-0.9, high=0.9, size=N) * np.pi
        else:
            th0 = (0.35 + 0.15 * np.arange(N) / max(1, N - 1)) * np.pi
    else:
        th0 = np.deg2rad(th0)

    if w0 is None:
        if args.random_init:
            w0 = rng.normal(0.0, 0.15, size=N)
        else:
            w0 = np.zeros(N, dtype=float)

    state = np.concatenate([th0, w0]).astype(float)
    t = 0.0

    total_L = float(np.sum(sim.L))
    lim = 1.08 * total_L

    fig = plt.figure(figsize=(8.2, 8.2))
    ax = fig.add_subplot(111)
    ax.set_aspect("equal", adjustable="box")
    ax.set_xlim(-lim, lim)
    ax.set_ylim(-lim, lim)
    ax.set_title(f"{N}-Pendulum")
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.grid(True, alpha=0.25)

    line, = ax.plot([], [], lw=2)
    masses_scatter = ax.scatter([], [], s=35)

    trail_len = 500
    trail = np.zeros((trail_len, 2), dtype=float)
    trail_i = 0
    trail_line, = ax.plot([], [], lw=1, alpha=0.6)

    def init():
        line.set_data([], [])
        masses_scatter.set_offsets(np.zeros((0, 2)))
        trail_line.set_data([], [])
        return line, masses_scatter, trail_line

    def step_physics():
        nonlocal state, t
        for _ in range(int(args.steps_per_frame)):
            state = rk4_step(sim.deriv, state, t, args.dt)
            t += args.dt

    def update(_frame):
        nonlocal trail_i
        step_physics()

        th = state[:N]
        x, yy = sim.positions(th)

        line.set_data(x, yy)
        masses_scatter.set_offsets(np.c_[x[1:], yy[1:]])

        tip = np.array([x[-1], yy[-1]])
        trail[trail_i % trail_len] = tip
        trail_i += 1
        k = min(trail_i, trail_len)
        idx = (np.arange(k) + max(0, trail_i - k)) % trail_len
        tr = trail[idx]
        trail_line.set_data(tr[:, 0], tr[:, 1])

        return line, masses_scatter, trail_line

    interval_ms = 1000.0 / float(args.fps)
    _ani = FuncAnimation(fig, update, init_func=init, interval=interval_ms, blit=True)
    plt.show()


if __name__ == "__main__":
    main()
